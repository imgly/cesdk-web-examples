import { baseURL } from '@/baseUrl';
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import './globals.css';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin']
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin']
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app'
};

export default function RootLayout({
  children
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <NextChatSDKBootstrap baseUrl={baseURL} />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

function NextChatSDKBootstrap({ baseUrl }: { baseUrl: string }) {
  return (
    <>
      <base href={baseUrl} />
      <script>{`window.innerBaseUrl = ${JSON.stringify(baseUrl)}`}</script>
      <script>
        {`(${(() => {
          const base = window.innerBaseUrl;
          const htmlElement = document.documentElement;
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (
                mutation.type === 'attributes' &&
                mutation.target === htmlElement
              ) {
                const attrName = mutation.attributeName;
                if (attrName && attrName !== 'suppresshydrationwarning') {
                  htmlElement.removeAttribute(attrName);
                }
              }
            });
          });
          observer.observe(htmlElement, {
            attributes: true,
            attributeOldValue: true
          });

          // Patch history API to work within ChatGPT's cross-origin iframe restrictions.
          // ChatGPT embeds widgets in iframes with restricted navigation.
          // Next.js router calls history.pushState/replaceState with absolute URLs,
          // which triggers security errors. We intercept these calls and rewrite
          // the provided URL so it always resolves to the current document origin.
          const sanitizeHistoryUrl = (value: unknown) => {
            try {
              if (value == null || value === '') {
                return window.location.href;
              }

              const parsed = new URL(String(value), window.location.href);
              const relative = parsed.pathname + parsed.search + parsed.hash;
              const safe = new URL(relative || '/', window.location.origin);
              return safe.toString();
            } catch (error) {
              console.warn('Failed to sanitize history URL', { value, error });
              return window.location.href;
            }
          };

          // eslint-disable-next-line no-restricted-globals
          const originalReplaceState = history.replaceState;
          // eslint-disable-next-line no-restricted-globals
          history.replaceState = (state, unused, url) => {
            const safeUrl = sanitizeHistoryUrl(url ?? window.location.href);
            // eslint-disable-next-line no-restricted-globals
            originalReplaceState.call(history, state, unused, safeUrl);
          };

          // eslint-disable-next-line no-restricted-globals
          const originalPushState = history.pushState;
          // eslint-disable-next-line no-restricted-globals
          history.pushState = (state, unused, url) => {
            const safeUrl = sanitizeHistoryUrl(url ?? window.location.href);
            // eslint-disable-next-line no-restricted-globals
            originalPushState.call(history, state, unused, safeUrl);
          };

          const appOrigin = new URL(base).origin;
          const isInIframe = window.self !== window.top;

          window.addEventListener(
            'click',
            (e) => {
              const a = (e?.target as HTMLElement)?.closest('a');
              if (!a || !a.href) return;
              const url = new URL(a.href, window.location.href);
              if (
                url.origin !== window.location.origin &&
                url.origin !== appOrigin
              ) {
                try {
                  if (window.openai) {
                    window.openai?.openExternal({ href: a.href });
                    e.preventDefault();
                  }
                } catch {
                  try {
                    // @ts-ignore
                    if (window.oai) {
                      // @ts-ignore
                      window.oai.openExternal({ href: a.href });
                      e.preventDefault();
                    }
                  } catch {
                    console.warn(
                      'oai.openExternal failed, likely not in OpenAI client'
                    );
                  }
                  console.warn(
                    'openExternal failed, likely not in OpenAI client'
                  );
                }
              }
            },
            true
          );

          if (isInIframe && window.location.origin !== appOrigin) {
            const originalFetch = window.fetch;

            window.fetch = (input: URL | RequestInfo, init?: RequestInit) => {
              let url: URL;
              if (typeof input === 'string' || input instanceof URL) {
                url = new URL(input, window.location.href);
              } else {
                url = new URL(input.url, window.location.href);
              }

              if (url.origin === appOrigin) {
                if (typeof input === 'string' || input instanceof URL) {
                  input = url.toString();
                } else {
                  input = new Request(url.toString(), input);
                }

                return originalFetch.call(window, input, {
                  ...init,
                  mode: 'cors'
                });
              }

              if (url.origin === window.location.origin) {
                const newUrl = new URL(baseUrl);
                newUrl.pathname = url.pathname;
                newUrl.search = url.search;
                newUrl.hash = url.hash;
                url = newUrl;

                if (typeof input === 'string' || input instanceof URL) {
                  input = url.toString();
                } else {
                  input = new Request(url.toString(), input);
                }

                return originalFetch.call(window, input, {
                  ...init,
                  mode: 'cors'
                });
              }

              return originalFetch.call(window, input, init);
            };
          }
        }).toString()})()`}
      </script>
    </>
  );
}
